#!/usr/bin/python3

import sys
import os
import logging
import lib_logger
import lib_system
import lib_wifi
import backendBridgeSocketIO

GET_LOCK_TIMEOUT = 10  # Max seconds to wait to get the lock, when using timeout mode
LOGS_FILE_PATH = "/media/persistent/system/config_wifi_logs"
LOGS_FILE_MAX_BYTES = 512*1024
LOGS_FILE_BACKUP_COUNT = 1

# Size of logs generated by get listAP, get connectedAP, set connectedAP: 12 KBytes
# Size of logs generated by enable, disable, get status: 1 KByte
# 512 KBytes --> History of the last 42 attempts to configure Wi-Fi, or 42 scans, or 512 operations of enabling, disabling Wi-Fi

logger = logging.getLogger(__name__)

# separator used to separate items in requests/answers
sep = "/@@/"

# WPA2-Enterprise. Default settings are for PEAPv0/MSCHAPV2
DEFAULT_EAP_METHOD = "peap"
DEFAULT_PHASE2_AUTHENTICATION = "MSCHAPV2"
DEFAULT_ANONYMOUS_ID = "anonymous"

# Wi-Fi RSSI monitor service file
WIFI_RSSI_MONITOR_SERVICE = "wifi_rssi_monitor.service"

def ShowHelpAndExit():
	'''
	Shows usage and exits application
	'''
	script_name = os.path.basename(sys.argv[0])
	print("")
	print("Wifi configuration help")
	print("")
	print("Usage:")
	print("%s clean [verbose]" % (script_name))
	print("     Cleans configuration (no connected AP, WiFi disabled)")
	print("%s enable [verbose]" % (script_name))
	print("     Enables WiFi")
	print("%s disable [force] [verbose]" % (script_name))
	print("     Disables WiFi")
	print("     Use force to disable Wi-Fi when the Wi-Fi dongle is not plugged")
	print("%s get listAP|connectedAP|status|RSSI|isDonglePresent [verbose]" % (script_name))
	print("     Gets the list of available APs, the AP actually connected to, wifi status, RSSI (%) or dongle presency")
	print("     An AP is a string formatted as: encoded ssid%sneeded_authentication_parameters%ssecure%sconnected%sRSSI%sname" % (sep, sep, sep, sep, sep))
	print("          encoded ssid is ssid encoded in hexadecimal (e.g. 53534944 for SSID)")
	print("          needed_authentication_parameters can contain any combination of U (Username),P (Password) and W (WPS pin)")
	print("          secure is True if the AP uses WPA2 security protocol, otherwise it is False")
	print("          connected is True if actually connected to this AP")
	print("          RSSI is Received Signal Strength Indicator (%%)")
	print("          examples:")
	print("               416e64726f69644150%sUP%sTrue%sTrue%s75%sAndroidAP" % (sep, sep, sep, sep,sep))
	print("               436f72706f726174654e6574%sP%sTrue%sFalse%s58%sCorporateNet" % (sep, sep, sep, sep, sep))
	print("               467265654775657374%s%sFalse%sFalse%s80%sFreeGuest" % (sep, sep, sep, sep, sep))
	print("%s set connectedAP encoded_ssid%s[encoded_user]%s[encoded_password] [add] [verbose]" % (script_name, sep, sep))
	print("     Connects to an AP using the requested authentication params %sencoded_user%sencoded_password" % (sep, sep))
	print("     If 'add' is passed as parameter, it doesn't remove the already registered connections")
	print("Examples:")
	print("%s get listAP" % script_name)
	print("%s set connectedAP 6950686f6e65%s67736f6c61%s636174616c61          (when user AND password are required)" % (script_name, sep, sep))
	print("%s set connectedAP 6950686f6e65%s67736f6c61%s636174616c61 verbose  (when user AND password are required, verbose mode)" % (script_name, sep, sep))
	print("%s set connectedAP 6950686f6e65%s%s636174616c61                    (when only password is required)" % (script_name, sep, sep))
	print("%s set connectedAP 6950686f6e65%s%s                                (when neither user nor password is required)" % (script_name, sep, sep))
	print("%s set connectedAP 6950686f6e65%s%s add                            (when neither user nor password is required, keep already registerd connections)" % (script_name, sep, sep))
	print("")
	print("HOW TO provide encoded_user and/or encoded_password from clear user/password:")
	print("Use hex_encode.py tool as shown in the example below")
	print("config_wifi.py set connectedAP 6950686f6e65/@@/$(hex_encode.py \"clear user\")/@@/$(hex_encode.py \"clear password\")")
	print("")
	exit(1)	# Error exit code


def RightArguments():
	'''
	Checks command line arguments
	Returns True/False
	'''
	len_argv = len(sys.argv)
	
	if (len_argv < 2):
		return False

	if (sys.argv[1] == "help"):
		return False

	if (sys.argv[1] == "get"):
		if (len_argv < 3):
			return False
		if (sys.argv[2] != "listAP" and sys.argv[2] != "connectedAP" and sys.argv[2] != "status" and sys.argv[2] != "RSSI" and sys.argv[2] != "isDonglePresent"):
			return False
	elif (sys.argv[1] == "set"):
		if (len_argv < 4):
			return False
		if (sys.argv[2] != "connectedAP"):
			return False
		for argument in sys.argv[4:]:
			if argument != "add" and argument != "verbose":
				return False
	elif (sys.argv[1] != "enable" and sys.argv[1] != "disable" and sys.argv[1] != "clean"):
		return False

	return True


def GetAuthenticationParams(auth_protocol_list):
	'''
	Gets the needed authentification params
	@auth_protocol_list: authentication protocols
	Returns a string which contains:
		U if user is needed
		P if password is needed	
		W if WPS pin is needed
	'''
	user_required = False
	password_required = False	
	wps_required = False
	for protocol in auth_protocol_list:
		if "ieee8021x" in protocol:						# WPA2 Enterprise. User name (Identity) and password (Passphrase) are required
			user_required = True	
			password_required = True
		if ("psk" in protocol) or ("wep" in protocol):	# WPA2 Personal with PSK encriptionm (WPA-PSK), or WEP. Only password (Passphrase) is required
			password_required = True
		if "wps" in protocol:							# WPS. WPS pin is required 
			wps_required = True

	auth_params = ""
	if user_required:
		auth_params = auth_params + "U"
	if password_required:
		auth_params = auth_params + "P"
	if wps_required:
		auth_params = auth_params + "W"
	
	return auth_params	


def BuildAP(name = "", auth_params = "", secure = "", connected = "", strength = 0):
	'''
	Returns a string with information of the AP
	The string is formatted "hex_ssid/@@/UPW/@@/secure/@@/connected/@@/signal_strength name" (U if user name is required, P if password is required, W if WPS pin is required)
	'''
	encoded_ssid = name.encode("utf-8").hex()
	# Remove separator if present
	readable_ssid = name.replace(sep,"")
	return "%s%s%s%s%s%s%s%s%i%s%s" % (encoded_ssid, sep, auth_params, sep, secure, sep, connected, sep, strength, sep, readable_ssid)


def NotifyBackendWifiDisabled():
	'''
	Notify the backend that wifi is disabled
	'''

	# Notify RSSI = 0 to backend, when Wi-Fi is not enabled/connected
	backendBridgeSocketIO.sendSystemStatusToBackend({
		'wifi_rssi': 0,
		'wifi_state': 'disabled'
		})

def GetWifiStatus():
	'''
	Prints the wifi status (enable/disable/error)
	Returns 0 on success, 1 on failure
	'''
	status, message =  wifi_manager.get_wifi_enabled_status()
	print(status)
	if status == "error":
		return 1
	else:
		return 0


def SetWifiConfiguration(enable):
	'''
	Sets wifi enable/disable state
	@enable: True to enable wifi, False to disable it
	Prints "Ok" on success operation, otherwise "Error"
	Returns 0 on success, 1 on error
	'''
	success, message =  wifi_manager.enable_wifi(enable)
	if not success and (("Already enabled" in message) or ("Already disabled" in message)):	# Consider "Already enabled/disabled" as no error
		success = True
	if success:
		if not enable:
			NotifyBackendWifiDisabled()
		print("Ok")
	else:
		print("Error")
	if success:
		return 0
	return 1

def GetListAP():
	'''
	Gets the list of available APs
	Prints available APS, one string per AP.
	Returns 0 on success, 1 on error
	'''
	success, message, wifi_services = wifi_manager.get_wifi_services(False)	# Don't list hidden networks
	if not success:
		logger.error(message)
		return 1
	logger.info("Success on getting list of available APs")
	APs = []
	for name, auth_protocol_list, secure, connected, strength in wifi_services:
		auth_params = GetAuthenticationParams(auth_protocol_list)
		access_point = BuildAP(name, auth_params, secure, connected, strength)
		if connected:
			logger.info("Actually connected to: %s" % (access_point))
		print(ascii(access_point))

	if success:
		return 0
	return 1


def GetConnectedAP():
	'''
	Gets the AP actually connected to
	Prints the AP as string 
	Returns 0 on succes, 1 on error
	'''
	success, message, connected_ap = wifi_manager.get_current_connected_service(get_hidden = False)	# Don't take hidden networks into account
	if not success:
		logger.error(message)
		return 1

	if connected_ap:
		auth_params = GetAuthenticationParams(connected_ap[1])
		access_point = BuildAP(connected_ap[0], auth_params, connected_ap[2], connected_ap[3], connected_ap[4])
		logger.info("Actually connected to: %s" % (access_point))
		print(access_point)

	return 0


def GetRSSI():
	'''
	Gets the Received Signal Strength Indicator (%) of the actual connected service
	Prints the RSSI as string
	Returns 0 on succes, 1 on error
	'''
	success, message, rssi, tech = wifi_manager.get_rssi()
	if not success:
		logger.error(message)
		return 1

	print("{} dBm".format(rssi))
	print("{} MHz".format(tech))
	return 0


def SetConnectedAP(access_point, unregister = True):
	'''
	Connects to an AP
	@access_point: the name (ssid) of the AP to connect to
	@unregister: True (default) if we want to unregister (remove) the previous registered connections
				 False if we want to keep previous registered connections
	Prints "Ok" on success, "Error error_name>:error_codevalue" on error
	returns 0 on success, 1 on error
	'''
	ssid=bytes.fromhex(access_point.split(sep)[0]).decode('utf-8')
	user=bytes.fromhex(access_point.split(sep)[1]).decode('utf-8')
	password=bytes.fromhex(access_point.split(sep)[2]).decode('utf-8')

	# If user and password are required, we are trying to connect to a network with ieee8021x security (enterprise)
	# Only PEAPV0/MSCHAPV2 is supported when trying to connect to ieee8021x networks
	# Set eap, phase2 authentication and anonymous identifier values for this kind of authentication
	eap_method=DEFAULT_EAP_METHOD if (user and password) else ""
	phase2_auth=DEFAULT_PHASE2_AUTHENTICATION if (user and password) else ""
	anonymous_id = DEFAULT_ANONYMOUS_ID if (user and password) else ""

	registered_services = []	
	auth_params_dict = {}

	if user:
		auth_params_dict["Identity"] = user
	if password:
		auth_params_dict["Passphrase"] = password
	if eap_method:
		auth_params_dict["EAP"] = eap_method
	if phase2_auth:
		auth_params_dict["Phase2"] = phase2_auth
	if anonymous_id:
		auth_params_dict["AnonymousIdentity"] = anonymous_id

	# Connect
	success, message, error_code = wifi_manager.connect(ssid, auth_params_dict, unregister)
	if not success:
		wifi_manager.remove(ssid) # Remove config files of the failed connection
		logger.error(message)
		NotifyBackendWifiDisabled()
		print("Error {}:{}".format(error_code.name, error_code.value))
		return error_code.value

	logger.info("Successfully connected to {}".format(ssid))

	print("Ok")
	return error_code.value


def CleanWifiConfiguration():
	'''
	Removes all Wifi configuration files. Disables wifi
	Returns 0 on success, 1 on error
	'''
	success, message = wifi_manager.remove_all()
	if not success:
		logger.error(message)
		return 1
	success = SetWifiConfiguration(False)
	if not success:
		logger.error("Error disabling Wifi. Try to clean configuration file")
		success, message = wifi_manager.disable_wifi_via_config_file()
		if not success:
			logger.error(message)
			logger.error("Error on cleaning Wifi configuration")
			return 1

		NotifyBackendWifiDisabled()

	logger.info("Success on cleaning Wifi configuration")		
	return 0


def ForceDisable():	
	'''
	Disables wifi via configuration file
	It's intended to be used to disable wifi when the wifi dongle is not plugged
	Prints "Ok" on success operation, otherwise "Error"
	Returns 0 on success, 1 on error
	'''
	success, message = wifi_manager.disable_wifi_via_config_file()
	if not success:
		logger.error(message)
		logger.error("Error on disabling Wifi via configuration file")
		print("Error")
		return 1

	logger.info("Success on disabling Wifi via configuration file")

	NotifyBackendWifiDisabled()

	print("Ok")
	return 0


def IsDonglePresent(logger):
	'''
	Returns 0 on success (dongle present), otherwise 1 (dongle not present)
	'''
	count, message, dongles_list = lib_wifi.list_USB_dongles(logger)
	if count >= 1:
		print("yes")
		return 0
	print("no")
	return 1


if __name__ == '__main__':	
	'''
	Main entry point
	Exits with 0 on success, other value on error
	'''	
	if not RightArguments():
		ShowHelpAndExit()

	tag_name = "config_wifi"
	lib_logger.add_handler_file(tag_name, LOGS_FILE_PATH, LOGS_FILE_MAX_BYTES, LOGS_FILE_BACKUP_COUNT)
	(is_syslog_active, _) = lib_system.isServiceActive(lib_logger.SYSLOGD_SERVICE)
	if is_syslog_active:	# Log to syslog only if syslog service is active to avoid exception messages on the console
		lib_logger.add_handler_syslog(tag_name)
	force = False
	unregister = True
	for argument in sys.argv:
		if argument == "verbose":
			lib_logger.add_handler_stdout(tag_name)
		if argument == "add":
			unregister = False
		if argument == "force":
			force = True

	# Log a header to signal start of configuration
	# Log the command line arguments
	lib_logger.log_header("Wi-Fi CONFIGURATION START - Log time is in UTC")
	command = ""
	for argument in sys.argv:
		command = command + argument + " "
	logger.info(command)

	# Actions that don't require WiFiManager
	if (sys.argv[1] == "get" and sys.argv[2] == "isDonglePresent"):
		exit_value = IsDonglePresent(logger)
		exit(exit_value)

	# Actions that require WiFiManager
	wifi_manager = lib_wifi.WiFiManager(logger)

	# Configuration operations have priority over wifi_rssi_monitor service
	# Stop wifi_rssi_monitor to ensure lock acquisition
	lib_system.stopService(WIFI_RSSI_MONITOR_SERVICE)

	# Acquire configuration lock, in timeout mode
	if not wifi_manager.acquire_lock(GET_LOCK_TIMEOUT):
		message = "Impossible to acquire configuration lock after %s seconds" % (GET_LOCK_TIMEOUT)
		print(message)
		logger.error(message)
		# Restart WiFi RSSI monitor
		lib_system.startService(WIFI_RSSI_MONITOR_SERVICE)
		exit(1)		

	# Execute the configuration action inside a try-finally block to ensure that the lock is released in any case
	try:
		exit_value = 1
		if (wifi_manager.verify_initialization() == False):
			logger.error("Error when initializing WiFiManager")
		elif sys.argv[1] == "enable":
			exit_value = SetWifiConfiguration(True)
		elif sys.argv[1] == "disable" and not force:
			exit_value = SetWifiConfiguration(False)
		elif sys.argv[1] == "get":
			if sys.argv[2] == "listAP":
				exit_value = GetListAP()
			elif sys.argv[2] == "status":
				exit_value = GetWifiStatus()
			elif sys.argv[2] == "connectedAP":
				exit_value = GetConnectedAP()
			elif sys.argv[2] == "RSSI":
				exit_value = GetRSSI()
		elif sys.argv[1] == "set":
			if sys.argv[2] == "connectedAP":
				exit_value = SetConnectedAP(sys.argv[3], unregister)
		# Execute "clean" and "disable force" despite initialization error
		if sys.argv[1] == "clean":
			exit_value = CleanWifiConfiguration()
		if sys.argv[1] == "disable" and force:
			exit_value = ForceDisable()
	except Exception as e:
		message = "Generic exception while executing %s: %s" % (command, e)
		print(message)
		logger.error(message)
	finally:
		# Release configuration lock
		wifi_manager.release_lock()
		# Restart WiFi RSSI monitor
		lib_system.startService(WIFI_RSSI_MONITOR_SERVICE)

	exit(exit_value)

